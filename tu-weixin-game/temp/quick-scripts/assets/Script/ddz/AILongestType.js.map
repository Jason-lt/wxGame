{"version":3,"sources":["AILongestType.js"],"names":["ddz","AILongestType","cc","Class","getOneLongestCardType","cards","LOGD","availableCards","types","RobotGlobal","judgeType","length","slice","pc","getPCArrayByPoint","sort","GlobalFuncs","_sortByPoint","newarr","index","aObj","oldIndex","oldObj","point","cardsInfo","cardsInfoIndex","push","count","lz_obj","getLaiziObject","reportLaiziCount","return_arr","findAvailableContinousDevide","_sortByCount","o1","o2"],"mappings":"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","file":"AILongestType.js","sourceRoot":"../../../../../assets/Script/ddz","sourcesContent":["//\n//  ddz_robot_longgest.js\n//  ddz\n//\n//  Created by Jiguan on 14-06-03.\n//  AI找最长牌型的功能，抽象出来以减少ddz_robot.js的代码量\n\nddz.AILongestType = cc.Class({\n\n\t// 判断牌型，传入牌的数组,返回可能的牌型或不合法等状态\n\tgetOneLongestCardType: function(cards) { //如果有癞子牌，传进来就是>53，转换成位置value就是15\n\t\tddz.LOGD(null, \"getLongestType\");\n\t\t//可用牌型\n\t\t//每一个元素是一个对象obj，obj{总张数count，牌的count值cards}\n\t\tvar availableCards = [];\n\n\t\t/*判断当前手牌是不是一个牌型\n\t\t *如果是，当前手牌便是最长的\n\t\t */\n\t\tvar types = ddz.RobotGlobal.judgeType(cards, false);\n\t\tif (types.length > 0) {\n\t\t\treturn cards.slice(0);\n\t\t}\n\n\t\t// 当前手牌不是一手牌，从中找顺子或者顺对\n\t\tvar pc = ddz.RobotGlobal.getPCArrayByPoint(cards);\n\t\tpc.sort(ddz.GlobalFuncs._sortByPoint);\n\n\t\t// 填补成连续的数组\n\t\tvar newarr = [];\n\t\tfor (var index = 0; index < 15; index++) {\n\t\t\tvar aObj = {\n\t\t\t\t'point': index,\n\t\t\t\t'count': 0,\n\t\t\t\t'cards': []\n\t\t\t};\n\n\t\t\tfor (var oldIndex = 0; oldIndex < pc.length; oldIndex++) {\n\t\t\t\tvar oldObj = pc[oldIndex];\n\n\t\t\t\tif (oldObj.point == aObj.point) {\n\t\t\t\t\taObj = oldObj;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 深拷贝\n\t\t\tvar cardsInfo = [];\n\t\t\tfor (var cardsInfoIndex = 0; cardsInfoIndex < aObj.cards.length; cardsInfoIndex++) {\n\t\t\t\tcardsInfo.push(aObj['cards'][cardsInfoIndex])\n\t\t\t}\n\t\t\tnewarr.push({\n\t\t\t\t'point': aObj.point,\n\t\t\t\t'count': aObj.count,\n\t\t\t\t'cards': cardsInfo\n\t\t\t})\n\t\t}\n\n\t\t///////////////////////////////////////////////////处理癞子\n\n\t\tvar lz_obj = ddz.RobotGlobal.getLaiziObject(pc);\n\n\t\t///////////////////////////////////////////////////处理癞子OVER\n\n\t\tvar reportLaiziCount = lz_obj.count;\n\t\t// 先考虑本身就能够构成这种牌型的牌\n\t\tlz_obj.count = 0;\n\n\t\t/////////////////////////////////////////////////////////////////////////////////找顺子\n\t\t//找最长顺子\n\t\tvar return_arr = ddz.RobotGlobal.findAvailableContinousDevide(newarr, 1, lz_obj).cards;\n\t\tif (return_arr.length > 0) {\n\t\t\tavailableCards.push({\n\t\t\t\t'count':return_arr.length,\n\t\t\t\t'cards':return_arr\n\t\t\t});\n\t\t}\n\n\n\t\treportLaiziCount = lz_obj.count;\n\t\t// 先考虑本身就能够构成这种牌型的牌\n\t\tlz_obj.count = 0;\n\n\t\t///////////////////////////////////////////////////////////////////////////////////////找连对\n\t\treturn_arr = ddz.RobotGlobal.findAvailableContinousDevide(newarr, 2, lz_obj).cards;\n\t\tif (return_arr.length > 0) {\n\t\t\tavailableCards.push({\n\t\t\t\t'count':return_arr.length,\n\t\t\t\t'cards':return_arr\n\t\t\t});\n\t\t}\n\n\t\treportLaiziCount = lz_obj.count;\n\t\t// 先考虑本身就能够构成这种牌型的牌\n\t\tlz_obj.count = 0;\n\n\t\t// 在顺子和连对都有的情况，如果连对牌的张数必须大于顺子牌的两倍\n\t\tif (availableCards.length == 2) {\n\t\t\tif (availableCards[0].count * 2 <= availableCards[1].count) {\n\t\t\t\treturn availableCards[1]['cards'];\n\t\t\t} else {\n\t\t\t\treturn availableCards[0]['cards'];\n\t\t\t}\n\t\t}\n\n\t\t//排序\n\t\tif(availableCards.length>0){\n\t\t\tavailableCards.sort(this._sortByCount);\n\t\t\tif (availableCards[0]['cards'].length>0) {\n\t\t\t\treturn availableCards[0]['cards'];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn cards;\n\t\t}\n\t},\n\t_sortByCount: function(o1, o2) {\n\t\treturn o2.count - o1.count;\n\t}\n});"]}