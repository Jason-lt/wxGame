{"version":3,"sources":["../../../../../../assets/Script/ComponentScript/component/assets/Script/ComponentScript/component/ddzsingle_robot_longest.js"],"names":["ddz","AILongestType","cc","Class","ctor","ai","AI","getOneLongestCardType","cards","availableCards","types","judgeType","length","slice","pc","_getPCArrayByPoint","sort","_sortByPoint","newarr","index","aObj","oldIndex","oldObj","point","cardsInfo","cardsInfoIndex","push","count","lz_obj","_getLaiziObject","reportLaiziCount","return_arr","_findAvailableContinousDevide","CardTable","print","oneobj","_dumpResultArr","_sortByCount","o1","o2"],"mappings":"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","file":"ddzsingle_robot_longest.js","sourceRoot":"../../../../../../assets/Script/ComponentScript/component","sourcesContent":["//\n//  ddz_robot_longgest.js\n//  ddz\n//\n//  Created by Jiguan on 14-06-03.\n//  AI找最长牌型的功能，抽象出来以减少ddz_robot.js的代码量\n\nddz.AILongestType = cc.Class({\n\tctor: function(ai) {\n\t\tthis.AI = ai;\n\t},\n\n\t// 判断牌型，传入牌的数组,返回可能的牌型或不合法等状态\n\tgetOneLongestCardType: function(cards) { //如果有癞子牌，传进来就是>53，转换成位置value就是15\n\t\t//可用牌型\n\t\t//每一个元素是一个对象obj，obj{总张数count，牌的count值cards}\n\t\tvar availableCards = [];\n\n\t\t/*判断当前手牌是不是一个牌型\n\t\t *如果是，当前手牌便是最长的\n\t\t */\n\t\tvar types = this.AI.judgeType(cards, false);\n\t\tif (types.length > 0) {\n\t\t\treturn cards.slice(0);\n\t\t}\n\n\t\t// 当前手牌不是一手牌，从中找顺子或者顺对\n\t\tvar pc = this.AI._getPCArrayByPoint(cards);\n\t\tpc.sort(this.AI._sortByPoint);\n\n\t\t// 填补成连续的数组\n\t\tvar newarr = [];\n\t\tfor (var index = 0; index < 15; index++) {\n\t\t\tvar aObj = {\n\t\t\t\t'point': index,\n\t\t\t\t'count': 0,\n\t\t\t\t'cards': []\n\t\t\t};\n\n\t\t\tfor (var oldIndex = 0; oldIndex < pc.length; oldIndex++) {\n\t\t\t\tvar oldObj = pc[oldIndex];\n\n\t\t\t\tif (oldObj.point == aObj.point) {\n\t\t\t\t\taObj = oldObj;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 深拷贝\n\t\t\tvar cardsInfo = [];\n\t\t\tfor (var cardsInfoIndex = 0; cardsInfoIndex < aObj.cards.length; cardsInfoIndex++) {\n\t\t\t\tcardsInfo.push(aObj['cards'][cardsInfoIndex])\n\t\t\t};\n\t\t\tnewarr.push({\n\t\t\t\t'point': aObj.point,\n\t\t\t\t'count': aObj.count,\n\t\t\t\t'cards': cardsInfo\n\t\t\t})\n\t\t}\n\t\t\n\t\t///////////////////////////////////////////////////处理癞子\n\n\t\tvar lz_obj = this.AI._getLaiziObject(pc);\n\n\n\t\t///////////////////////////////////////////////////处理癞子OVER\n\n\n\t\tvar reportLaiziCount = lz_obj.count;\n\t\t// 先考虑本身就能够构成这种牌型的牌\n\t\tlz_obj.count = 0;\n\n\t\t/////////////////////////////////////////////////////////////////////////////////找顺子\n\t\t//找最小顺子\n\t\tvar return_arr = this.AI._findAvailableContinousDevide(newarr, 1, lz_obj).cards;\n\t\tif (return_arr.length > 0) {\n\t\t\tddz.CardTable.print(return_arr);\n\n\t\t\tvar oneobj = {\n\t\t\t\t'count':return_arr.length,\n\t\t\t\t'cards':return_arr\n\t\t\t}\n\t\t\tavailableCards.push(oneobj);\n\t\t}\n\n\t\t// 找带癞子拼成的\n\t\t//lz_obj.count = reportLaiziCount;\n\n\t\t// var return_arr = this.AI._findAvailableContinousDevide(newarr, 1, lz_obj).cards;\n\t\t// if (return_arr.length > 0) {\n\t\t// \tthis.AI._dumpResultArr('found shunzi', return_arr);\n\n\t\t// \tvar oneobj = {\n\t\t// \t\t'count':return_arr.length,\n\t\t// \t\t'cards':return_arr\n\t\t// \t}\n\t\t// \tavailableCards.push(oneobj);\n\t\t// }\n\t\t//////////////////////////////////////////////////////////////////////////////////////找顺子over\n\n\t\treportLaiziCount = lz_obj.count;\n\t\t// 先考虑本身就能够构成这种牌型的牌\n\t\tlz_obj.count = 0;\n\n\t\t///////////////////////////////////////////////////////////////////////////////////////找连对\n\t\treturn_arr = this.AI._findAvailableContinousDevide(newarr, 2, lz_obj).cards;\n\t\tddz.CardTable.print(return_arr);\n\t\tif (return_arr.length > 0) {\n\t\t\tthis.AI._dumpResultArr('found liandui', return_arr);\n\n\t\t\tvar oneobj = {\n\t\t\t\t'count':return_arr.length,\n\t\t\t\t'cards':return_arr\n\t\t\t}\n\t\t\tavailableCards.push(oneobj);\n\t\t}\n\n\t\t// 找带癞子拼成的\n\t\t// lz_obj.count = reportLaiziCount;\n\n\t\t// var return_arr = this.AI._findAvailableContinous(newarr, 2, lz_obj).cards;\n\t\t// if (return_arr.length > 0) {\n\t\t// \tthis.AI._dumpResultArr('found liandui', return_arr);\n\n\t\t// \tvar oneobj = {\n\t\t// \t\t'count':return_arr.length,\n\t\t// \t\t'cards':return_arr\n\t\t// \t}\n\t\t// \tavailableCards.push(oneobj);\n\t\t// }\n\t\t///////////////////////////////////////////////////////////////////////////////////////找连对over\n\n\t\treportLaiziCount = lz_obj.count;\n\t\t// 先考虑本身就能够构成这种牌型的牌\n\t\tlz_obj.count = 0;\n\n\t\t///////////////////////////////////////////////////////////////////////////////////////找飞机\n\t\t// var return_arr = this.AI._findAvailableAircraft(newarr, lz_obj);\n\t\t// if (return_arr.length > 0) {\n\t\t// \tthis.AI._dumpResultArr('found aircraft', return_arr);\n\t\t// \tvar oneobj = {\n\t\t// \t\t'count':return_arr.length,\n\t\t// \t\t'cards':return_arr\n\t\t// \t}\n\t\t// \tavailableCards.push(oneobj);\n\t\t// }\n\n\t\t// 找带癞子拼成的飞机\n\t\t// lz_obj.count = reportLaiziCount;\n\t\t// var return_arr = this.AI._findAvailableAircraft(newarr, lz_obj);\n\t\t// if (return_arr.length > 0) {\n\t\t// \tthis.AI._dumpResultArr('found aircraft', return_arr);\n\n\t\t// \tvar oneobj = {\n\t\t// \t\t'count':return_arr.length,\n\t\t// \t\t'cards':return_arr\n\t\t// \t}\n\t\t// \tavailableCards.push(oneobj);\n\t\t// }\n\t\t///////////////////////////////////////////////////////////////////////////////////////找飞机over\n\n\t\t\n\t\t///////////////////////////////////////////////////////////////////////////////////////找三带\n\t\t// var return_arr = this.AI._findAvailableThree(newarr, lz_obj); //找第一个出现的3个, 内部考虑了先找不带癞子的\n\t\t// if (return_arr.length > 0) {\n\t\t// \tthis.AI._dumpResultArr('found three', return_arr);\n\n\t\t// \tvar oneobj = {\n\t\t// \t\t'count':return_arr.length,\n\t\t// \t\t'cards':return_arr\n\t\t// \t}\n\t\t// \tavailableCards.push(oneobj);\n\t\t// }\n\t\t///////////////////////////////////////////////////////////////////////////////////////找三带over\n\n\n\t\t// /////////////////////////////////////////////////////////////////////////////////////////找对子\n\t\t// if (availableCards.length == 0) {\n\t\t// \tvar pairs = this.AI._findMinDouble(lz_obj, pc, 1, [], false);\n\t\t// \tddz.CardTable.print(pairs);\n\t\t// \tif (pairs.length > 0) {\n\t\t// \t\tvar oneobj = {\n\t\t// \t\t\t'count':2,\n\t\t// \t\t\t'cards':pairs[0]\n\t\t// \t\t}\n\t\t// \t\tavailableCards.push(oneobj);\n\t\t// \t}\n\t\t// }\n\t\t// /////////////////////////////////////////////////////////////////////////////////////////找对子OVER\n\n\t\t// /////////////////////////////////////////////////////////////////////////////////////////找单牌\n\t\t// if (availableCards.length == 0) {\n\t\t// \tvar single = this.AI._findMinSingle(lz_obj, pc, 1, [], false);\n\t\t// \tif (single.length > 0) {\n\t\t// \t\tvar oneobj = {\n\t\t// \t\t\t'count':1,\n\t\t// \t\t\t'cards':single\n\t\t// \t\t}\n\t\t// \t\tavailableCards.push(oneobj);\n\t\t// \t}\n\t\t// };\n\t\t/////////////////////////////////////////////////////////////////////////////////////////找单牌over\n\n\t\t//排序\n\t\tif(availableCards.length>0){\n\t\t\tavailableCards.sort(this._sortByCount);\n\t\t\tif (availableCards[0]['cards'].length>0) {\n\t\t\t\treturn availableCards[0]['cards'];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn cards;\n\t\t}\n\t\t\n\n\t},\n\t_sortByCount: function(o1, o2) {\n\t\treturn o1['count'] < o2['count'];\n\t},\n});\n\n"]}